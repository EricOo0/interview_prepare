# 计算机网络

<details>
<summary>ICMP</summary>

\- ICMP 网络控制消息协议，用于在IP协议中发送控制消息，运行在IP层，用于测试网络状况等  

\- ping和tracroute发送的是ICMP报文  

\- ICMP报文负责差错控制--负责错误报告，不负责错误纠正（IP报文只负责消息传输，不管差错控制）  

\- 常见错误：终点不可达，超时，源点抑制  

</details>



<details>
<summary>DNS</summary>

\- DNS是域名系统（Domain Name System），是将域名和IP地址的之间进行转换的一项服务gethostbyname  

\- 域名转换时会先区浏览器缓存查询域名对应的IP，如果没有，会去本地HOSTS里查询，如果没有才会到DNS服务 器上去寻找。  

\- DNS运行在应用层，域名解析是基于UDP的（快，简单）  

</details>





<details>
<summary>ARP</summary>

\- ARP地址解析协议，提供IP地址和MAC地址的转换服务；属于网络层  

\- ARP地址请求是广播，向所有用户请求目的IP的mac地址；arp回复是单播。  

\- linux下用 arp -a 查看arp缓存；一个地址在arp缓存中有老化时间，过期会被删除。  

\- arp攻击：arp是一种不安全的协议--arp洪泛 arp欺骗  

</details>

<details>
<summary>TCP/IP和UDP部分</summary>

<details>

 <summary>TCP和UDP区别</summary>    

- Tcp面向连接，需要三次握手四次挥手，是可靠传输;而udp不面向连接是不可靠传输（尽最大努力传输）  

- TCP是字节流而UDP是报文  

- TCP有拥塞避免（作用于网络）-慢开始，快恢复，快重传，流量控制（作用于接收放，接收窗口），UDP无  

- TCP适用于文件传输等对可靠性要求高的（邮件，文件传输），UDP适用于实时应用（语言，视频）  

- TCP首部20字节，UDP首部8字节  

- TCP慢，资源消耗多，udp快，资源消耗少  


</details>

<details>

<summary>拥塞避免算法</summary>

> 发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。  

***\*******\***慢开始**\********\***算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小  

***\*******\***拥塞避免**\********\***当拥塞窗口大于拥塞门限，采用拥塞避免算法，即拥塞窗口线性增加+1  

当发生超时情况--没有收到确认就认为是网络拥塞，慢开始门限设为当前拥塞窗口一半，拥塞窗口设为1  

***\*******\***快重传**\********\***：发送方收到连续三个同一个确认报文，就直接重传，不等超时  



***\*******\***快恢复**\********\***：发送方收到连续三个同一个确认报文，把慢开始门限设为一半，执行拥塞避免算法  

> TCP报文结构:  
>
> 头部包含：源目的端口号，序号与确认序号，校验和，报文长度，数据偏移（UDP可能在IP层分片）等  



 </details>   



 <details>
<summary>分包和粘包</summary>

> 当发送间隔很短，包长度很小时，socket内部会把几个报文打包成一个发送
>
> 当报文太大的时候，socket内部会拆分成几个报文发送
>
> 解决办法：加头部，标明数据长度，或加起止标志

 </details>





<details>



<summary>四次挥手的状态</summary>



> 1、客户端发送请求关闭报文fin ,客户端进入fin_wait1
>
> 2、服务器接收fin并回复fin_ack,服务器进入close_wait
>
> 3、客户端接收ack，客户端进入fin_wait2;
>
> 4、服务器发出关闭请求fin，服务器进入last_ack
>
> 5、客户端接收并回复确认，进入time_wait状态
>
> 四次挥手是因为全双工，为了双方断开



</details>



<details>



<summary>三次握手</summary>



> 1、客户端发出syn请求，进入Syn_send状态
>
> 2、服务器接收syn，回复syn+ack，进入syn_recv状态
>
> 3、客户端接收到syn+ack，回复ack，客户端进入established状态
>
> 4、服务器接收到ack,进入established
>
> 为什么要三次握手，因为tcp是全双工的，需要测速双方的收发能力都是正常的。



\* 可以两次握手吗?  

> 不可以，如果只进行两次握手：
>
> 1、当服务器的确认丢失的时候，服务器以为成功建立了连接，但客户端却认为没有建立。此时服务器向客户端发送数据会被丢弃
>
> 2、客户端发出连接请求超时后到达服务器，服务器仍接收请求发出确认，但客户端此时不需要建立连接，浪费资源

</details>





<details>


<summary>time_wait</summary>



* 为什么要有time_wait 阶段

> 1、客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
>
> 2、考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。
>
> 3、服务器出现大量time_wait(短链接很多)解决办法：1、修改内核减少time_wait时间 2、设置socket可重用

* Close_wait过多怎么解决

> 客户端一侧发起关闭连接请求，服务器方回复确认后，服务器方会进入close_wait 状态。
>
> close_wait过多的原因：服务端socket忙于读写，并没有close socket，无法进入到last_ack状态
>
> 解决方法：1、使用完socket要调用close关闭；设置TCP连接时长--keep_alive_time，强行关闭一些没有活动的连接

* 如果已经建立了连接，但是客户端突然出现故障了怎么办？

> 如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。

* 初始化双发的序列号；为什么要随机初始化

> 防止被攻击

* UDP最大报文长度：

> 1480（因为以太网帧长度为1500，ip首部20字节）

* 第三次握手失败怎么办？

> 服务器超时没收到请求重传，5次失败后关闭连接；客户端如果此时发送数据会受到RST响应包

![image1 tcp](image/tcp.jpg)

</details>



</details>





<details>



<summary>HTTP 部分</summary>





<details>



<summary>http和https区别？</summary>



\- 端口：http-80  https-443  



\- 安全性：https有加密机制更安全  



\- 协议：http运行在tcp之上，https运行在ssl层上（安全套接字层）而ssl运行在tcp层上。  



  </details>



  



  <details>



  <summary>https过程</summary>





> HTTPS实际上就是HTTP穿上了SSL/TLS的外套; 增加一层SSL（安全套接字）  



密钥磋商过程：  



> 客户端发起一个http请求，连接端口443  
>
> 服务器把自己的数字证书，公钥等信息发给客户端（非对称密钥）  
>
> 客户端验证证书合法性，生成对称密钥，用公钥加密后发给服务器  



\* HTTP请求过程：  



> 域名解析（DNS）获得IP -> 对服务器发起TCP连接（3次握手）-> 连接成功后可以发送http请求（post，get）->服务器响应，发送页面->浏览器解析渲染  



\* 状态码：  



> 2xx：成功响应 3xx:重定向状态码 4xx：客户端错误 5xx:服务器错误  



\* http格式：  



> 请求行（request line-请求方法+url+协议版本）、请求头部（header）、空行和请求数据4个部分  



\* HTTP长连接短链接：  



- Http 1.0：短链接 耗费太多资源，每次发送都有链接  



- Http 1.1：长连接+心跳机制keeplive  --长链接的目的可以复用   



> 比如请求一个网页：如果是短链接-需要建立十几个tcp链接，传输css，js等一系列资源；长链接的话只需要复用一个tcp链接
>
> 长链接+连接池--防止高并发占用太多资源  



- http2.0:特点：多路复用-允许单个连接多个请求



- http3.0:基于UDP，主要是快-减少了握手的时间和TLS；解决弱网情况下队头阻塞等问题；



\* http端口号  



> http端口是80 https是443  



\* HTTP的无连接和无状态  



> HTTP协议是应用层协议，主要五大特点：支持客户-服务器模式，简单快速，灵活，无连接，无状态  
>
> 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，服务器无法判断用户身份。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。--（用cookie和session解决）  
>
> 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  



</details>





<details>



<summary> session和cookie </summary>



***\*******\***Cookie**\********\***  



​    Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。  



***\*******\***Session**\********\***    



​    Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。  



***\*******\***Token**\********\***



​    客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。  



</details>



</details>



<details>



<summary>其他</summary>





* 什么是nginx:  



> Nginx是一款轻量级的Web服务器、也可以用来做反向代理服务，具有简单的负载均衡；  
>
> 支持高并发（epoll，多进程，多路复用和事件通知）-异步非阻塞，响应更快-可以缓存静态文件（作为缓存服务器）  
>
> 启动Nginx后，其实就是在80端口启动了Socket服务进行监听  
>
> 分为master进程和worker进程（多进程单线程-）  



* Ospf,rip,stp的理解：  



* DHCP协议：  



> 动态获取IP；四个过程：发现过程（寻找dhcp服务器地址）提供阶段（服务区提供IP）选择阶段（客户端选择第一个提供的IP）确认阶段（服务器确认）  



</details>

