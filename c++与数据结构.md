# C++&&数据结构


<details>

<summary>STL **（点我打开详情）**</summary>

    推荐侯捷老师的C++系列视频

* STL 六大组件

  STL是C++的标准模版库，利用模版为泛型编程提供了基础。

<details>

<summary>容器</summary>

七种基本容器：

* 序列式容器：

  * array：Array:固定长度，不可增长；array.data()可返回数组的第一个元素的地址;实际上就是包装了一个数组，没有构造和析构函数

  * vector：可动态增长（由分配器复制），每当空间不足时，会重新申请一个两倍的空间，将原来空间的数据复制过去;类中包含三个指针start;end；end_of_storage和一个迭代器；
              .size()返回元素的数量；.capacity()返回可容纳元素的大小>=size()；

  * deque:双向队列，可向两侧动态扩充；在内存空间中时分段连续的;

    deque是分段连续；每段叫一个buffer；内部有个vector：map用来存储各个buffer的指针；迭代器有四个元素：cur（迭代器当前指向元素的地址），first（当前buffer的起始地址），last（当前buffer的最后一个位置）
      如何模拟连续空间：
    重载了[]操作符，可以通过下标访问
    重载操作符++;--;利用控制中心map跳到其他buffer，模拟连续空间

  * list：双向链表，容器内有一个自己类的sort函数

* 非序列式容器：

  * set：底层都是红黑树（高度平衡）;不分keyvalue；有自己的find函数

  * map

  * multiset

  * multimap

    set和map底层为红黑树，自动维护顺序；unordered_map和unordered_set底层是哈希表，由数组和链表实现，防止哈希冲突使用拉链法和开放定址法，还有溢出表法

   ![image relationship](https://github.com/EricOo0/my_repo/blob/master/Image/components.png)

*  不定序容器：
  unordered_map:底层是vector+链表(hashtable)
  通过一个散列函数（简单的方法是除以容器大小取余），将对象放到对应下标（节省容器空间）；如果发生碰撞用链表把他们串一起。
  重哈希：链表太长的时候（元素数量大于bucket长度时），把bucket vector增长（即换2倍长的vector），重新hash
  篮子buket一定大于元素  

![image structure](https://github.com/EricOo0/my_repo/blob/master/Image/structure.png)
![image structure2](https://github.com/EricOo0/my_repo/blob/master/Image/unorder_.png)



</details>

<details>

<summary>迭代器</summary>

iterator--一个泛化的指针，用来操作容器，连接算法和容器的桥梁；算法不需要知道容器的类型和内容，只需要通过迭代器来获取信息或操作。

每种容器都实现了自己的迭代器，通过迭代器可以获得容器内部的数据结构；

内部重载了++，--，*等操作符，简化操作

</details>

<details>

<summary>算法</summary>

用于操作容器内部元素，可以对元素进行排序，搜索，修改等操作；通过迭代器，可以实现一次算法用于不同类型的容器；为所有容器提供一致的算法接口。

</details>

<details>

<summary>分配器</summary>

负责空间配置与管理。

各种容器背后的内存分配都是由allocator实现的。

</details>

<details>

<summary>适配器</summary>

适配器是一种接口类，一种用来修饰容器(container)或仿函数(functor)或迭代器(iterator)接口的东西。

容器适配器：stack,queue都是适配器，基于deque实现，不提供迭代器

迭代器适配器

函数适配器

</details>

<details>

<summary>仿函数</summary>

行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。

</details>

</details>

#### 常问八股：

<details>

<summary>多态</summary>

* 静态多态和动态多态：

>一种接口，多种方法。  
>静态多态：编译期间完成的多态，函数运行之前就知道函数地址了—函数重载与隐藏，函数模板  
>动态多态：运行时完成的多态，在函数运行的时候才知道具体的函数地址—虚函数

* 重载和覆盖和隐藏：  

>重载：函数名相同，参数不同；要求在一个类中  
>覆盖：子类覆盖父类的函数，同名同参；必须是virtual  
>隐藏：如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆，重载要求在一个类中）。  
>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字（虚函数）。此时，基类的函数被隐藏（注意别与覆盖混淆，如果基类中有virtual关键字，而为覆盖）

* c语言没有函数重载：

>编译阶段，c++会对函数进行重命名以保证函数名唯一，c语言不会，仅在函数名前加_。

* 构造函数一般不是虚函数：

>创建类的时候还没有虚函数表，如果是虚函数无法调用构造函数  
>析构函数一般是虚函数，当基类指针指向子类对象的时候可以释放子类对象的空间（默认不是虚函数因为默认时不会被继承的类）； （父类指针不能访问子类的虚函数）  
>
>* 纯虚函数，虚函数：  

>父类中没有实现的虚函数是纯虚函数，必须被继承和重写  
>虚继承解决了菱形继承  ：只保留公共父类的一份副本。
>
>* 哪些函数不可以被继承：
>
>>构造函数，析构函数，运算符重载  
>>子类继承父类时，会有一个默认的自己的构造函数
>
>* 虚函数表什么时候创建
>        
>
>>虚函数表在编译时创建，编译阶段为构造函数增加虚函数表指针赋值的操作。虚函数表存放在常量区rodata

</details>

<details>

<summary>继承</summary>

* 三种继承方式：      

>默认是private继承。  
>public：is a 继承；公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。  
>private：has a;私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。而基类的私有成员仍然是私有的。  
>protected：has a;保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。


//公有继承                      对象访问    成员访问  
public    -->  public              Y         Y  
protected -->  protected           N         Y  
private   -->  private             N         N  

//保护继承                      对象访问    成员访问  
public    -->  protected           N         Y  
protected -->  protected           N         Y  
private   -->  protected           N         N  

//私有继承                      对象访问    成员访问  
public    -->  private             N         Y  
protected -->  private             N         Y  
private   -->  private             N         N  

* =delete

>C++11中，当我们定义一个类的成员函数时，如果后面使用"=delete"去修饰，那么就表示这个函数被定义为deleted，也就意味着这个成员函数不能再被调用，否则就会出错。

</details>

* 源文件到可执行文件的过程：      

编译过程：  
>预处理：#include文件的展开，宏的替换，注释删除，添加行号和符号标识--产生.i文件 gcc -E main.c main.i 
编译：翻译代码，产生汇编代码  
汇编:汇编代码翻译成二进制，产生符号表

链接过程：  
>    链接：各个模块独立编译，通过链接将他们组合起来；符号表合并和重定位-编译过程中为确定地址的符号定位到对应地址

* 指针和引用的区别:  
  
>引用只是一个别名，需要先初始化变量，没有分配空间；指针有自己的地址空间；引用不能被改变，好处是传参的适合时候不需要重新开辟空间进行初始化。

* New和malloc区别：  
  
>new/delete是C++关键字，需要编译器支持。  
> malloc/free是库函数，需要头文件支持  
> new不用计算分配大小，malloc需要指定分配大小  
> new返回的是对象类型的指针，malloc返回的是void指针  
> new失败抛出异常，malloc失败返回null
>
>malloc 底层实现有两种调用方式：
>
>​	小空间（小于128k）用brk指针；大空间用mmap；
>
>​	这两种分配方式都是分配虚拟空间，使用时调用缺页中断分配物理内存；
>
>​	为什么用两种方式：
>
>​		**brk****分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因），而mmap分配的内存可以单独释放。**
>
>

* 对象的什么函数不能被声明为虚函数  

>构造函数，内联函数inline，静态函数）
* C++内存布局
  
>代码段 全局、静态区 常量区 堆 栈
* 指针占几个字节：
  
>和系统有关，32位机固定占4字节
* Static关键字：
        
>变量存储位置是栈，静态变量存储位置是静态区（全局区），没有初始化的话自动初始化成0  
全局静态变量：作用域为本文件，其他文件不可见  
局部静态变量：作用域仍为局部，但是离开作用域不会销毁，下次进入不会再次初始化  
静态函数：本文件可见，其他文件不可见；static函数不能再头文件声明， static作用域会本文件，每次include这个头文件都会定义一遍这个变量，导致有多份同名变量。  
静态成员和静态成员函数：属于类，不属于对象；

* const关键字
>1、如果不希望变量被改变，则在变量前面加const  
2、返回值为常量，在函数返回类型前加const，则表示函数返回值为常量，只能为右值  
3、 常量函数--在函数后面加const，则该函数为常量成员函数，不可以修改成员变量的值，也不可以调用非常量成员函数
* Extern 关键字
>被extern"C"修饰的变量和函数是按照C语言方式编译和连接的
* volatile和mutable关键字  
>C/C++中的volatile关键字和const对应，用来修饰变量，用于告诉编译器该变量值是不稳定的，可能被更改。使用volatile注意事项：  
(1). 编译器会对带有volatile关键字的变量禁用优化:不进行代码优化和重排，保证volatile变量间的顺序性，编译器不会进行乱序优化    
(2). 当多个线程都要用到某一个变量且该变量的值会被改变时应该用volatile声明，该关键字的作用是防止编译器优化把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么多个线程有可能有的使用内存中的变量，有的使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中取出，而不是使用已经存在寄存器中的值。  
mutable：  
被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。  
* 函数指针：
>int (*p)(int, int)  
数组名和指针不一样：    
Sizeof(数组名)是数组长度  
Size(指针)是4/8  
数组名本身代表的就是数组的起始地址，指针有自己的地址指向数组  
* Sizeof 和 strlen：

>算数组长度时sizeof会多1，他计算\0结束符。strlen不算

* 预处理 -> 编译 -> 汇编 -> 链接

* 四种cast转换：  
        
>xxx_cast< newtype > (data)  
Static_cast：用于各种隐式转换  
dynamic_cast:动态转换，用于各种类的向上向下转换  
const_cast：将const转换成非const  
reinterpret_cast：什么都能转但是有风险  

* 四种智能指针：自动析构指针，防止内存泄漏
  
>Shared_ptr循环引用会导致内存泄漏  
Auto_ptr：c++11弃用；类似unique指针，转移时会出问题，转移所有权时会将原指针置空？  
Shared_ptr:：共享指针，引用计数  
Weak_ptr: 防止share_ptr死循环不释放资源；不增加引用计数  
Unique_ptr:独占指针  
std:move的作用是用来转移所有权，被转移的对象会被置空？  

* 虚函数表存放位置
  
>常量区
* 拷贝构造可以用值传递吗？
        
>不可以；如果使用值传递，则还需要调用拷贝构造将形参赋给实参，会无限循环。对象作为参数传递时，会调用拷贝构造。
* inline内联函数

>内联函数是以代码膨胀为代价减少函数调用的开销；一般在调用函数的时候会不断地进行函数地入栈出栈操作；通过内联函数，在编译的过程中将函数体展开，减少开销

* 虚函数可以内联吗？  
>虚函数在没有用到多态特性的话可以内联；内联是在编译期展开，虚函数多态则在运行期通过虚函数指针找到函数地址  
https://zhuanlan.zhihu.com/p/256202496  

* Set和map
  
>都是关联容器，map时key-value，set时key；都不允许修改key，但可以删除，map支持下标索引，底层都是红黑树
* 编译错误和运行错误：  

>编译错误--编译器可以检测出来，比如语法错误，符号错误等  
运行错误--代码的逻辑错误，得靠程序员自己检查，编译不会报错，比如内存越界溢出等
* 哈希表：
>通过散列函数将键值映射到数组某一位置  
解决哈希碰撞的方法：
拉链法-通过链表存储多个value  
重哈希  
开放定址法  
建立公共溢出区  
* Map的insert和[]的区别 ？

>[]是操作符重载，如果搜索的key不存在，会创建一个value为默认值的插入到红黑树中。
当插入新key-value时，insert效率更高
当key-value存在时，insert不能成功插入，[]可以更新value

    ```
    #include<map>
    #include<iostream>
    using namespace std;
    int main(void){
    map<int,int> test;
    test.insert(make_pair(1,1));
    test.insert(make_pair(1,2));
    test.insert(make_pair(2,1));
    test[2]=2;
    cout<<test[1]<<endl;//输出 1 --证明key存在了insert会失败
    cout<<test[2]<<endl;//输出 2
    cout<<test[0]<<endl;//输出 0 创建并插入了个默认值
    cout<<test.size();//3
    }
    ```

* 红黑树和AVL树
>    红黑树和AVL树都是自平衡的二叉搜索树；  
    AVL树是严格的平衡二叉树，左右子树的最大高度差不超过1，当插入失衡时需要进行旋转  
    红黑树不追求严格的平衡，但是在插入和删除的时候代价比AVL树小  
    AVL查找效率更高，红黑树插入和删除效率更高；实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。    
* 堆的数据结构  
https://zhuanlan.zhihu.com/p/25820535  
>堆是一种经过排序的树形数据结构，每个节点都有一个值，且满足以下两个条件：  
1、堆中某个节点的值总是不大于或不小于其父节点的值；  
2、堆总是一棵完全二叉树。  
堆可以分为最大堆和最小堆；  
因为是完全二叉树，节点编号是有规律的，所以也可以用数组来表示一个堆(bfs);  
堆的插入和删除：  
最小堆：先插入到树尾，再一层一层上滤（如果小于父节点，则交换）  
删除：将尾节点放到根节点，再层层下滤，（如果大于孩子，则把最小的放到根）  
构建：找到最后一个非叶子节点的节点，判断是否比孩子节点小，如果不是，则和最小的的交换，一直下滤；然后找倒数第二个非叶子节点的节点，一直循环到根节点；  
* 序列化和反序列化  
>程序员在编写应用程序的时候往往需要将程序的某些数据存储在内存中，然后将其写入某个文件或是将它传输到网络中的另一台计算机上以实现通讯。这个将 程序数据转化成能被存储并传输的格式的过程被称为“序列化”（Serialization），而它的逆过程则可被称为“反序列化” （Deserialization）。  
protobuf、json、xml  
https://blog.csdn.net/K346K346/article/details/51754431  

* 时间复杂度相关

> 大O表示法表示最坏情况
>
> 排序算法最好情况O(nlogn)
>
> Dfs：搜索情况：回溯+visited数组（以邻接表存储） O(E) E为边数--所有边最多被访问两次一次遍历一次回溯
>
> BFS：搜索情况：队列+visited数组（以邻接表存储） O(V) V为顶点 -- 所有顶点会被访问一次，
>
> DFS：排列等情况： O(n!)  类似于递归思路，每次拆分成几个子问题
>
> 递归算法：O(k^n)
